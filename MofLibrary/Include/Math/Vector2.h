/*************************************************************************//*!
					
					@file	Vector2.h
					@brief	2Dベクトル演算関連

															@author	CDW
															@date	2014.05.14
*//**************************************************************************/

//ONCE
#ifndef		__VECTOR2__H__

#define		__VECTOR2__H__

//INCLUDE
#include	"Random.h"

namespace Mof {

	//前方定義
	struct Matrix33;
	struct Matrix44;

	/*******************************//*!
	@brief	2D座標構造体

			2D座標を扱うための構造体。

	@author	CDW
	*//********************************/
	typedef struct MOFLIBRARY_API Vector2Impl {
		union {
			float					fv[2];
			struct {
				union {
					MofFloat		x;						//!<XもしくはU
					MofFloat		u;						//!<XもしくはU
				};
				union {
					MofFloat		y;						//!<YもしくはV
					MofFloat		v;						//!<YもしくはV
				};
			};
		};
	}Vector2Impl, Float2;
	
	/*******************************//*!
	@brief	2D座標構造体

			2D座標を扱うための構造体。

	@author	CDW
	*//********************************/
	typedef struct MOFLIBRARY_API Vector2 : public Vector2Impl {
		/*************************************************************************//*!
				@brief			コンストラクタ
				@param			None

				@return			None
		*//**************************************************************************/
		Vector2();
		/*************************************************************************//*!
				@brief			コンストラクタ
				@param[in]		vx			X
				@param[in]		vy			Y

				@return			None
		*//**************************************************************************/
		Vector2(MofFloat vx,MofFloat vy);
		/*************************************************************************//*!
				@brief			コンストラクタ
				@param[in]		pv			座標

				@return			None
		*//**************************************************************************/
		Vector2(LPMofFloat pv);
		/*************************************************************************//*!
				@brief			コピーコンストラクタ
				@param[in]		pObj		コピーベクトル

				@return			None
		*//**************************************************************************/
		Vector2(const Vector2& pObj);
					
		//----------------------------------------------------------------------------
		////Operator
		//----------------------------------------------------------------------------
	
		/*************************************************************************//*!
				@brief			floatキャスト<br>
								内部の座標をfloatポインタとしてそのまま返す。
		*//**************************************************************************/
		operator LPMofFloat ();
		/*************************************************************************//*!
				@brief			代入
		*//**************************************************************************/
		Vector2& operator = ( const Vector2Impl& v );
		/*************************************************************************//*!
				@brief			+取得
		*//**************************************************************************/
		Vector2 operator + () const;
		/*************************************************************************//*!
				@brief			-取得
		*//**************************************************************************/
		Vector2 operator - () const;
		/*************************************************************************//*!
				@brief			+=演算
		*//**************************************************************************/
		Vector2& operator += ( const Vector2Impl& v );
		/*************************************************************************//*!
				@brief			-=演算
		*//**************************************************************************/
		Vector2& operator -= ( const Vector2Impl& v );
		/*************************************************************************//*!
				@brief			floatとの*=演算
		*//**************************************************************************/
		Vector2& operator *= ( const MofFloat v );
		/*************************************************************************//*!
				@brief			Vector2との*=演算
		*//**************************************************************************/
		Vector2& operator *= ( const Vector2Impl& v );
		/*************************************************************************//*!
				@brief			Matrix33との*=演算
		*//**************************************************************************/
		Vector2& operator *= ( const Matrix33& m );
		/*************************************************************************//*!
				@brief			Matrix44との*=演算
		*//**************************************************************************/
		Vector2& operator *= ( const Matrix44& m );
		/*************************************************************************//*!
				@brief			floatとの/=演算
		*//**************************************************************************/
		Vector2& operator /= ( const MofFloat v );
		/*************************************************************************//*!
				@brief			Vector2との/=演算
		*//**************************************************************************/
		Vector2& operator /= ( const Vector2Impl& v );
		/*************************************************************************//*!
				@brief			+演算
		*//**************************************************************************/
		Vector2 operator + ( const Vector2Impl& v ) const;
		/*************************************************************************//*!
				@brief			-演算
		*//**************************************************************************/
		Vector2 operator - ( const Vector2Impl& v ) const;
		/*************************************************************************//*!
				@brief			floatとの*演算
		*//**************************************************************************/
		Vector2 operator * ( const MofFloat v ) const;
		/*************************************************************************//*!
				@brief			Vector2との*演算
		*//**************************************************************************/
		Vector2 operator * ( const Vector2Impl& v ) const;
		/*************************************************************************//*!
				@brief			Matrix33との*演算
		*//**************************************************************************/
		Vector2 operator * ( const Matrix33& m ) const;
		/*************************************************************************//*!
				@brief			Matrix44との*演算
		*//**************************************************************************/
		Vector2 operator * ( const Matrix44& m ) const;
		/*************************************************************************//*!
				@brief			floatとの/演算
		*//**************************************************************************/
		Vector2 operator / ( const MofFloat v ) const;
		/*************************************************************************//*!
				@brief			Vector2との/演算
		*//**************************************************************************/
		Vector2 operator / ( const Vector2Impl& v ) const;
		/*************************************************************************//*!
				@brief			配列指定によるVector2メンバへのアクセス
		*//**************************************************************************/
		MofFloat& operator [] ( int i );
		/*************************************************************************//*!
				@brief			配列指定によるVector2メンバへのアクセス
		*//**************************************************************************/
		const MofFloat& operator [] ( int i ) const;
		/*************************************************************************//*!
				@brief			==判断
		*//**************************************************************************/
		bool operator == ( const Vector2Impl& v ) const;
		/*************************************************************************//*!
				@brief			!=判断
		*//**************************************************************************/
		bool operator != ( const Vector2Impl& v ) const;
	}Vector2,TextureCoords;
	
	/*************************************************************************//*!
			@brief			+演算
	*//**************************************************************************/
	Vector2 operator + (const Vector2Impl& v1, const Vector2Impl& v2);
	/*************************************************************************//*!
			@brief			+演算
	*//**************************************************************************/
	Vector2 operator - (const Vector2Impl& v1, const Vector2Impl& v2);

	/*******************************//*!
	@brief	2D座標演算クラス

			Vector2構造体を扱うためのスタティッククラス。

	@author	CDW
	*//********************************/
	class MOFLIBRARY_API CVector2Utilities {
	public:
		/*************************************************************************//*!
				@brief			ベクトルの長さを調べる
				@param[in]		v			調べるベクトル

				@return			引数ベクトルの長さ
		*//**************************************************************************/
		static MofFloat Length(const Vector2Impl& v);
		/*************************************************************************//*!
				@brief			ベクトルの長さの2乗を調べる
				@param[in]		v			調べるベクトル

				@return			引数ベクトルの長さの2乗
		*//**************************************************************************/
		static MofFloat LengthSquare(const Vector2Impl& v);
		/*************************************************************************//*!
				@brief			ベクトル間の距離を調べる
				@param[in]		v1			調べるベクトル
				@param[in]		v2			調べるベクトル

				@return			引数ベクトルの長さ
		*//**************************************************************************/
		static MofFloat Distance(const Vector2Impl& v1, const Vector2Impl& v2);
		/*************************************************************************//*!
				@brief			単位ベクトルを求める
				@param[in]		v1			計算ベクトル
				@param[out]		OutVec		出力ベクトル

				@return			None
		*//**************************************************************************/
		static void Normal(const Vector2Impl& v1,Vector2Impl& OutVec);

		/*************************************************************************//*!
				@brief			ベクトル１からベクトル２へとt(０〜１)の値で線形補間をおこなう
				@param[in]		v1			元ベクトル１
				@param[in]		v2			元ベクトル２
				@param[in]		t			変化率（０〜１の範囲を取る）

				@return			補間ベクトル
		*//**************************************************************************/
		static Vector2 Lerp(const Vector2& v1, const Vector2& v2, MofFloat t);
		/*************************************************************************//*!
				@brief			ベクトル１からベクトル２へとstepで移動をおこなう<br>
								stepの値がベクトル間の距離より大きい場合、v2の位置で停止する
				@param[in]		v1			元ベクトル１
				@param[in]		v2			元ベクトル２
				@param[in]		step		移動量

				@return			補間ベクトル
		*//**************************************************************************/
		static Vector2 Move(const Vector2& v1, const Vector2& v2, MofFloat step);

	private:
		//作成を禁止する
		CVector2Utilities(){};
		CVector2Utilities(const CVector2Utilities& pObj){};
	};

	/*******************************//*!
	@brief	2D座標クラス

			Vector2構造体を扱うための関数を含めたクラス。

	@author	CDW
	*//********************************/
	class MOFLIBRARY_API CVector2 : public Vector2 , public IMofBase {
	public:
		/*************************************************************************//*!
				@brief			コンストラクタ
				@param			None

				@return			None
		*//**************************************************************************/
		CVector2();
		/*************************************************************************//*!
				@brief			コンストラクタ
				@param[in]		vx			X
				@param[in]		vy			Y

				@return			None
		*//**************************************************************************/
		CVector2(MofFloat vx,MofFloat vy);
		/*************************************************************************//*!
				@brief			コンストラクタ
				@param[in]		pv			座標

				@return			None
		*//**************************************************************************/
		CVector2(LPMofFloat pv);
		/*************************************************************************//*!
				@brief			コピーコンストラクタ
				@param[in]		pObj		コピーベクトル

				@return			None
		*//**************************************************************************/
		CVector2(const Vector2& pObj);
		/*************************************************************************//*!
				@brief			コピーコンストラクタ
				@param[in]		pObj		コピーベクトル

				@return			None
		*//**************************************************************************/
		CVector2(const CVector2& pObj);
		/*************************************************************************//*!
				@brief			デストラクタ
				@param			None

				@return			None
		*//**************************************************************************/
		~CVector2();

		/*************************************************************************//*!
				@brief			ベクトルの長さを調べる
				@param			None

				@return			ベクトルの長さ
		*//**************************************************************************/
		MofFloat Length(void) const;
		/*************************************************************************//*!
				@brief			ベクトルの長さの2乗を調べる
				@param			None

				@return			ベクトルの長さの2乗
		*//**************************************************************************/
		MofFloat LengthSquare(void) const;
		/*************************************************************************//*!
				@brief			単位ベクトルを求める
				@param[out]		OutVec		出力ベクトル

				@return			None
		*//**************************************************************************/
		void Normal(Vector2& OutVec) const;
		
		/*************************************************************************//*!
				@brief			値を絶対値にする
				@param			None

				@return			None
		*//**************************************************************************/
		void Absolute(void);
		/*************************************************************************//*!
				@brief			値のクリッピング
				@param[in]		l			最小値
				@param[in]		h			最大値

				@return			None
		*//**************************************************************************/
		void Cliping(const MofFloat l,const MofFloat h);
		/*************************************************************************//*!
				@brief			値のクリッピング
				@param[in]		l			最小値
				@param[in]		h			最大値

				@return			None
		*//**************************************************************************/
		void Cliping(const Vector2& l,const Vector2& h);

		/*************************************************************************//*!
				@brief			数値の設定
				@param[in]		vx			X
				@param[in]		vy			Y

				@return			None
		*//**************************************************************************/
		void SetValue(MofFloat vx,MofFloat vy);
		
		/*************************************************************************//*!
				@brief			最大の数値の取得
				@param			None

				@return			X,Yの最大値
		*//**************************************************************************/
		MofFloat GetMaxValue(void) const;
		/*************************************************************************//*!
				@brief			絶対値の最大の数値の取得
				@param			None

				@return			X,Yの絶対値の最大値
		*//**************************************************************************/
		MofFloat GetMaxAbsValue(void) const;
		/*************************************************************************//*!
				@brief			最低の数値の取得
				@param			None

				@return			X,Yの最小値
		*//**************************************************************************/
		MofFloat GetMinValue(void) const;
		/*************************************************************************//*!
				@brief			絶対値の最低の数値の取得
				@param			None

				@return			X,Yの絶対値の最小値
		*//**************************************************************************/
		MofFloat GetMinAbsValue(void) const;

		//----------------------------------------------------------------------------
		////Operator
		//----------------------------------------------------------------------------

		/*************************************************************************//*!
				@brief			代入
		*//**************************************************************************/
		CVector2& operator = (const Vector2Impl& v);
		/*************************************************************************//*!
				@brief			代入
		*//**************************************************************************/
		CVector2& operator = ( const Vector2& v );

		//クラス基本定義
		MOF_LIBRARYCLASS(CVector2,MOF_VECTOR2CLASS_ID);
	};
	
	//ポインタ置き換え
	typedef CVector2*			LPVector2,*LPTextureCoords;

	//INLINE INCLUDE
	#include	"Vector2.inl"

}

#endif

//[EOF]